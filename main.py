# main.py  (aiogram >= 3.7,<3.9)
import os
import io
import json
import asyncio
import logging
import datetime
import calendar
from pathlib import Path
from collections import defaultdict
from typing import Dict, Any, Iterable

from aiogram import Bot, Dispatcher, Router, F
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import (
    BotCommand,
    KeyboardButton,
    Message,
    ReplyKeyboardMarkup,
    BufferedInputFile,
    BotCommandScopeDefault,
    BotCommandScopeChat,
)
from aiogram.filters import CommandStart, Command, CommandObject
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from zoneinfo import ZoneInfo

from openpyxl import Workbook
from openpyxl.styles import Alignment, Font
from openpyxl.utils import get_column_letter

# ================== –ù–ê–°–¢–†–û–ô–ö–ò ==================

# –¢–æ–∫–µ–Ω –∏–∑ ENV
RAW_TOKEN = os.getenv("BOT_TOKEN", "")
BOT_TOKEN = (
    RAW_TOKEN.replace("\u00A0", " ").replace("\r", "").replace("\n", "").strip().strip('"').strip("'")
)
if not BOT_TOKEN or ":" not in BOT_TOKEN:
    raise RuntimeError(f"BOT_TOKEN –≤—ã–≥–ª—è–¥–∏—Ç –Ω–µ–≤–µ—Ä–Ω–æ. RAW={RAW_TOKEN!r}")

# –†–æ–ª–∏
OWNER_ID  = 104653853
ADMIN_IDS = [104653853, 1155243378]  # –º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä—è—Ç—å

# –§–∞–π–ª—ã –¥–∞–Ω–Ω—ã—Ö
EMP_FILE   = Path("employees.json")
SHIFT_FILE = Path("shifts.json")

# –ú–°–ö
MSK = ZoneInfo("Europe/Moscow")

# ===== –ù–æ—Ä–º–∞—Ç–∏–≤—ã –¥–ª—è –û–¢–ß–Å–¢–ê (Excel) ‚Äî –ù–ï –ú–ï–ù–Ø–ï–ú =====
START_NORM = datetime.time(8, 0)      # –Ω–∞—á–∞–ª–æ: –Ω–æ—Ä–º–∞
START_OK_TILL = datetime.time(8, 10)  # –Ω–∞—á–∞–ª–æ: –¥–æ–ø—É—Å—Ç–∏–º–æ –¥–æ
END_NORM = datetime.time(17, 30)      # –∫–æ–Ω–µ—Ü: –Ω–æ—Ä–º–∞
END_OK_TILL = datetime.time(17, 40)   # –∫–æ–Ω–µ—Ü: –¥–æ–ø—É—Å—Ç–∏–º–æ –¥–æ

# ===== –î–æ–ø—É—Å–∫–∏ –¢–û–õ–¨–ö–û –¥–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤ –≤ –ë–û–¢–ï =====
PROMPT_EARLY_OK_FROM = datetime.time(7, 45)  # –Ω–∞—á–∞–ª–æ –¥–æ 07:45 ‚Äî —Å–ø—Ä–æ—Å–∏–º –ø—Ä–∏—á–∏–Ω—É
PROMPT_START_OK_TILL = datetime.time(8, 10)  # –ø–æ—Å–ª–µ 08:10 ‚Äî —Å–ø—Ä–æ—Å–∏–º –ø—Ä–∏—á–∏–Ω—É
PROMPT_END_OK_TILL   = datetime.time(17, 45) # –ø–æ—Å–ª–µ 17:45 ‚Äî —Å–ø—Ä–æ—Å–∏–º –ø—Ä–∏—á–∏–Ω—É

# ================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==================
logging.basicConfig(level=logging.INFO)
bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()
dp.include_router(router)

# ================== –î–ê–ù–ù–´–ï (–ü–û –î–ù–Ø–ú, –ú–°–ö) ==================
# shifts_by_date["YYYY-MM-DD"][user_id] = {...}
shifts_by_date: Dict[str, Dict[int, Dict[str, Any]]] = defaultdict(dict)

# –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤: ID -> –§–ò–û (–∏–∑ —Ñ–∞–π–ª–∞)
DEFAULT_EMPLOYEES = {
    str(OWNER_ID): "OWNER",
}
EMPLOYEES: Dict[int, str] = {}  # –∑–∞–≥—Ä—É–∑–∏–º –∏–∑ —Ñ–∞–π–ª–∞ –Ω–∏–∂–µ

# –û–∂–∏–¥–∞–Ω–∏–µ –≤–≤–æ–¥–∞ –ø—Ä–∏—á–∏–Ω—ã: { user_id: "start_early"|"start_late"|"end_early"|"end_late" }
pending_reason: Dict[int, str] = {}

# ================== –£–¢–ò–õ–ò–¢–´ ==================
def msk_now() -> datetime.datetime:
    return datetime.datetime.now(MSK)

def today_key() -> str:
    return msk_now().date().isoformat()

def fmt_hm(dt: datetime.datetime | None) -> str:
    if not dt:
        return "‚Äî"
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=MSK)
    return dt.astimezone(MSK).strftime("%H:%M")

def is_weekend(date: datetime.date) -> bool:
    return calendar.weekday(date.year, date.month, date.day) >= 5  # 5=–°–±, 6=–í—Å

def fio(uid: int) -> str:
    return EMPLOYEES.get(uid, f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π ({uid})")

def is_admin(uid: int) -> bool:
    return uid in ADMIN_IDS or uid == OWNER_ID

def is_allowed(uid: int) -> bool:
    return uid == OWNER_ID or uid in ADMIN_IDS or uid in EMPLOYEES

def ensure_allowed(message: Message) -> bool:
    uid = message.from_user.id
    if not is_allowed(uid):
        asyncio.create_task(message.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."))
        return False
    return True

def today_shift(uid: int) -> Dict[str, Any]:
    return shifts_by_date[today_key()].setdefault(uid, {})

# ================== I/O –°–ü–†–ê–í–û–ß–ù–ò–ö–ê –ò –°–ú–ï–ù ==================
def load_employees() -> dict[int, str]:
    if EMP_FILE.exists():
        try:
            raw = json.loads(EMP_FILE.read_text("utf-8"))
            return {int(k): str(v) for k, v in raw.items()}
        except Exception as e:
            logging.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å employees.json: %s", e)
    # —Å–æ–∑–¥–∞—ë–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    EMP_FILE.write_text(json.dumps(DEFAULT_EMPLOYEES, ensure_ascii=False, indent=2), "utf-8")
    return {int(k): v for k, v in DEFAULT_EMPLOYEES.items()}

def save_employees() -> None:
    out = {str(k): v for k, v in EMPLOYEES.items()}
    EMP_FILE.write_text(json.dumps(out, ensure_ascii=False, indent=2), "utf-8")

def dt_to_iso(dt: datetime.datetime | None) -> str | None:
    return dt.astimezone(MSK).isoformat() if dt else None

def dt_from_iso(s: str | None) -> datetime.datetime | None:
    if not s:
        return None
    return datetime.datetime.fromisoformat(s)  # tz-aware

def save_shifts() -> None:
    data_out: dict[str, dict[str, dict[str, Any]]] = {}
    for day, users in shifts_by_date.items():
        data_out[day] = {}
        for uid, d in users.items():
            data_out[day][str(uid)] = {
                "start": dt_to_iso(d.get("start")),
                "end": dt_to_iso(d.get("end")),
                "start_reason": d.get("start_reason"),
                "end_reason": d.get("end_reason"),
                "comment": d.get("comment"),
                "comment_done": d.get("comment_done"),
            }
    SHIFT_FILE.write_text(json.dumps(data_out, ensure_ascii=False, indent=2), "utf-8")

def load_shifts() -> None:
    if not SHIFT_FILE.exists():
        return
    try:
        data_in = json.loads(SHIFT_FILE.read_text("utf-8"))
    except Exception as e:
        logging.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å shifts.json: %s", e)
        return
    for day, users in data_in.items():
        shifts_by_date[day] = {}
        for uid_str, d in users.items():
            uid = int(uid_str)
            shifts_by_date[day][uid] = {
                "start": dt_from_iso(d.get("start")),
                "end": dt_from_iso(d.get("end")),
                "start_reason": d.get("start_reason"),
                "end_reason": d.get("end_reason"),
                "comment": d.get("comment"),
                "comment_done": d.get("comment_done"),
            }

# –ó–∞–≥—Ä—É–∑–∏–º –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–æ—Ü–µ—Å—Å–∞
EMPLOYEES = load_employees()
load_shifts()

# ================== –ö–ù–û–ü–ö–ò ==================
user_buttons = [
    [KeyboardButton(text="–°–º–µ–Ω—É –Ω–∞—á–∞–ª üè≠"), KeyboardButton(text="–°–º–µ–Ω—É –∑–∞–∫–æ–Ω—á–∏–ª üè°")],
    [KeyboardButton(text="–ú–æ–π —Å—Ç–∞—Ç—É—Å"), KeyboardButton(text="–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è")],
]
admin_buttons = user_buttons + [[KeyboardButton(text="–û—Ç—á–µ—Ç üìà"), KeyboardButton(text="–°—Ç–∞—Ç—É—Å —Å–º–µ–Ω—ã")]]

def kb(uid: int) -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=admin_buttons if is_admin(uid) else user_buttons,
        resize_keyboard=True
    )

# ================== –ö–û–ú–ê–ù–î–´ ==================
@router.message(CommandStart())
async def cmd_start(message: Message):
    if not ensure_allowed(message): return
    await message.answer("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç —É—á—ë—Ç–∞ —Ä–∞–±–æ—á–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ DUSBERG!", reply_markup=kb(message.from_user.id))

@router.message(Command("whoami"))
async def cmd_whoami(message: Message):
    if not ensure_allowed(message): return
    uid = message.from_user.id
    role = "OWNER" if uid == OWNER_ID else ("ADMIN" if is_admin(uid) else "USER")
    await message.answer(
        f"–¢—ã: <b>{role}</b>\n"
        f"–§–ò–û: <b>{fio(uid)}</b>\n"
        f"ID: <code>{uid}</code>",
        reply_markup=kb(uid)
    )

# ----- OWNER-–ö–æ–º–∞–Ω–¥—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–æ–º -----
def owner_only(uid: int) -> bool:
    return uid == OWNER_ID

@router.message(Command("emp_list"))
async def emp_list(message: Message):
    if not owner_only(message.from_user.id):
        return
    if not EMPLOYEES:
        return await message.answer("–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –ø—É—Å—Ç.")
    lines = [f"{uid}: {name}" for uid, name in sorted(EMPLOYEES.items(), key=lambda kv: kv[0])]
    await message.answer("–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏:\n" + "\n".join(lines))

@router.message(Command("emp_add"))
async def emp_add(message: Message, command: CommandObject):
    if not owner_only(message.from_user.id):
        return
    text = (command.args or "").strip()
    if not text:
        return await message.answer('–§–æ—Ä–º–∞—Ç: /emp_add <id> <–§–ò–û –≤ –∫–∞–≤—ã—á–∫–∞—Ö –∏–ª–∏ –±–µ–∑>')
    parts = text.split(maxsplit=1)
    if len(parts) < 2:
        return await message.answer('–ù—É–∂–Ω–æ –∏ ID, –∏ –§–ò–û. –ü—Ä–∏–º–µ—Ä: /emp_add 123 "–ò–≤–∞–Ω–æ–≤ –ò.–ò."')
    try:
        new_id = int(parts[0])
    except ValueError:
        return await message.answer("ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
    name = parts[1].strip().strip('"').strip("'")
    if not name:
        return await message.answer("–ü—É—Å—Ç–æ–µ –∏–º—è.")
    EMPLOYEES[new_id] = name
    save_employees()
    await message.answer(f"–î–æ–±–∞–≤–ª–µ–Ω: {new_id} ‚Äî {name}")

@router.message(Command("emp_del"))
async def emp_del(message: Message, command: CommandObject):
    if not owner_only(message.from_user.id):
        return
    text = (command.args or "").strip()
    if not text:
        return await message.answer("–§–æ—Ä–º–∞—Ç: /emp_del <id>")
    try:
        uid = int(text)
    except ValueError:
        return await message.answer("ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
    if EMPLOYEES.pop(uid, None) is None:
        return await message.answer("–¢–∞–∫–æ–≥–æ ID –Ω–µ—Ç –≤ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–µ.")
    save_employees()
    await message.answer(f"–£–¥–∞–ª—ë–Ω: {uid}")

@router.message(Command("emp_reload"))
async def emp_reload(message: Message):
    if not owner_only(message.from_user.id):
        return
    global EMPLOYEES
    EMPLOYEES = load_employees()
    await message.answer("–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–µ–Ω –∏–∑ —Ñ–∞–π–ª–∞.")

# ================== –ë–ò–ó–ù–ï–°-–õ–û–ì–ò–ö–ê ==================
@router.message(F.text == "–°–º–µ–Ω—É –Ω–∞—á–∞–ª üè≠")
async def handle_start(message: Message):
    if not ensure_allowed(message): return
    uid = message.from_user.id
    now = msk_now()
    shift = today_shift(uid)

    if shift.get("start") and shift.get("end") is None:
        await message.answer("–°–º–µ–Ω–∞ —É–∂–µ –Ω–∞—á–∞—Ç–∞. –°–Ω–∞—á–∞–ª–∞ –∑–∞–≤–µ—Ä—à–∏ —Ç–µ–∫—É—â—É—é.", reply_markup=kb(uid))
        return

    shift["start"] = now
    shift["end"] = None
    shift["start_reason"] = None
    shift["end_reason"] = None
    shift["comment"] = None
    pending_reason.pop(uid, None)
    save_shifts()

    t = now.time()
    if is_weekend(now.date()):
        pending_reason[uid] = "start_early"
        await message.answer("–°–µ–≥–æ–¥–Ω—è –≤—ã—Ö–æ–¥–Ω–æ–π. –£–∫–∞–∂–∏ –ø—Ä–∏—á–∏–Ω—É –Ω–∞—á–∞–ª–∞ —Å–º–µ–Ω—ã (—Ç–µ–∫—Å—Ç–æ–º):", reply_markup=kb(uid))
    elif t < PROMPT_EARLY_OK_FROM:
        pending_reason[uid] = "start_early"
        await message.answer("–°–º–µ–Ω–∞ –Ω–∞—á–∞—Ç–∞ —Å–ª–∏—à–∫–æ–º —Ä–∞–Ω–æ (–¥–æ 07:45). –£–∫–∞–∂–∏ –ø—Ä–∏—á–∏–Ω—É (—Ç–µ–∫—Å—Ç–æ–º):", reply_markup=kb(uid))
    elif t > PROMPT_START_OK_TILL:
        pending_reason[uid] = "start_late"
        await message.answer("–°–º–µ–Ω–∞ –Ω–∞—á–∞—Ç–∞ –ø–æ–∑–∂–µ 08:10. –£–∫–∞–∂–∏ –ø—Ä–∏—á–∏–Ω—É –æ–ø–æ–∑–¥–∞–Ω–∏—è (—Ç–µ–∫—Å—Ç–æ–º):", reply_markup=kb(uid))
    else:
        await message.answer("–°–º–µ–Ω–∞ –Ω–∞—á–∞—Ç–∞. –ü—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ–≥–æ –¥–Ω—è!", reply_markup=kb(uid))

@router.message(F.text == "–°–º–µ–Ω—É –∑–∞–∫–æ–Ω—á–∏–ª üè°")
async def handle_end(message: Message):
    if not ensure_allowed(message): return
    uid = message.from_user.id
    now = msk_now()
    shift = today_shift(uid)

    if not shift.get("start"):
        await message.answer("–°–º–µ–Ω–∞ –µ—â—ë –Ω–µ –Ω–∞—á–∞—Ç–∞.", reply_markup=kb(uid))
        return
    if shift.get("end"):
        await message.answer("–°–º–µ–Ω–∞ —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.", reply_markup=kb(uid))
        return

    shift["end"] = now
    pending_reason.pop(uid, None)
    save_shifts()

    t = now.time()
    if t < END_NORM:
        pending_reason[uid] = "end_early"
        await message.answer("–°–º–µ–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —Å–ª–∏—à–∫–æ–º —Ä–∞–Ω–æ (–¥–æ 17:30). –£–∫–∞–∂–∏ –ø—Ä–∏—á–∏–Ω—É (—Ç–µ–∫—Å—Ç–æ–º):", reply_markup=kb(uid))
    elif t > PROMPT_END_OK_TILL:
        pending_reason[uid] = "end_late"
        await message.answer("–°–º–µ–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –ø–æ–∑–∂–µ 17:45. –£–∫–∞–∂–∏ –ø—Ä–∏—á–∏–Ω—É –ø–µ—Ä–µ—Ä–∞–±–æ—Ç–∫–∏ (—Ç–µ–∫—Å—Ç–æ–º):", reply_markup=kb(uid))
    else:
        await message.answer("–°–ø–∞—Å–∏–±–æ! –•–æ—Ä–æ—à–µ–≥–æ –æ—Ç–¥—ã—Ö–∞!", reply_markup=kb(uid))

@router.message(F.text == "–ú–æ–π —Å—Ç–∞—Ç—É—Å")
async def handle_status(message: Message):
    if not ensure_allowed(message): return
    uid = message.from_user.id
    data = shifts_by_date.get(today_key(), {}).get(uid)
    if not data:
        await message.answer("–°–º–µ–Ω–∞ –Ω–µ –Ω–∞—á–∞—Ç–∞.", reply_markup=kb(uid))
        return

    lines = [
        f"–°–º–µ–Ω–∞ –Ω–∞—á–∞—Ç–∞ –≤: {fmt_hm(data.get('start'))}",
        f"–°–º–µ–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –≤: {fmt_hm(data.get('end'))}",
    ]
    if data.get("start_reason"):
        lines.append(f"–ü—Ä–∏—á–∏–Ω–∞ –Ω–∞—á–∞–ª–∞: {data['start_reason']}")
    if data.get("end_reason"):
        lines.append(f"–ü—Ä–∏—á–∏–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è: {data['end_reason']}")
    if data.get("comment"):
        lines.append(f"–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: {data['comment']}")

    await message.answer("\n".join(lines), reply_markup=kb(uid))

@router.message(F.text == "–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è")
async def handle_help(message: Message):
    if not ensure_allowed(message): return
    await message.answer(
        "–î–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞—á–∞–ª–∞ —Å–º–µ–Ω—ã –Ω–∞–∂–º–∏ ¬´–°–º–µ–Ω—É –Ω–∞—á–∞–ª üè≠¬ª. –î–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è ‚Äî ¬´–°–º–µ–Ω—É –∑–∞–∫–æ–Ω—á–∏–ª üè°¬ª.\n"
        "–ï—Å–ª–∏ –±–æ—Ç —Å–ø—Ä–∞—à–∏–≤–∞–µ—Ç –ø—Ä–∏—á–∏–Ω—É ‚Äî –æ—Ç–≤–µ—Ç—å –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º (—Ç–µ–∫—Å—Ç–æ–º), —ç—Ç–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—Å—è –∫–∞–∫ –ø—Ä–∏—á–∏–Ω–∞ –Ω–∞—á–∞–ª–∞/–∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.\n"
        "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ—è—Å–Ω–µ–Ω–∏—è –º–æ–∂–Ω–æ –ø—Ä–∏—Å–ª–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º ‚Äî —ç—Ç–æ –æ–±—â–∏–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π.",
        reply_markup=kb(message.from_user.id)
    )

@router.message(F.text == "–°—Ç–∞—Ç—É—Å —Å–º–µ–Ω—ã")
async def handle_shift_status(message: Message):
    if not ensure_allowed(message): return
    if not is_admin(message.from_user.id):
        await message.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", reply_markup=kb(message.from_user.id))
        return

    day = today_key()
    day_data = shifts_by_date.get(day, {})
    if not day_data:
        await message.answer("–°–µ–≥–æ–¥–Ω—è —Å–º–µ–Ω –Ω–µ—Ç.", reply_markup=kb(message.from_user.id))
        return

    lines = []
    for uid, data in day_data.items():
        s = fmt_hm(data.get("start"))
        e = fmt_hm(data.get("end"))
        who = fio(uid)
        suffix = []
        if data.get("start_reason"):
            suffix.append("–ø—Ä–∏—á–∏–Ω–∞ –Ω–∞—á–∞–ª–∞ –µ—Å—Ç—å")
        if data.get("end_reason"):
            suffix.append("–ø—Ä–∏—á–∏–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –µ—Å—Ç—å")
        extra = f" ({', '.join(suffix)})" if suffix else ""
        lines.append(f"{who}: –Ω–∞—á–∞—Ç–∞ –≤ {s}, –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –≤ {e}{extra}")
    await message.answer("\n".join(lines), reply_markup=kb(message.from_user.id))

# ================== –û–¢–ß–Å–¢ –ü–û –î–ò–ê–ü–ê–ó–û–ù–£ (XLSX) ==================
class ReportStates(StatesGroup):
    waiting_period = State()

def daterange_inclusive(d1: datetime.date, d2: datetime.date) -> Iterable[datetime.date]:
    step = 1 if d1 <= d2 else -1
    cur = d1
    while True:
        yield cur
        if cur == d2:
            break
        cur = cur + datetime.timedelta(days=step)

def parse_date(s: str) -> datetime.date | None:
    try:
        y, m, d = s.split("-")
        return datetime.date(int(y), int(m), int(d))
    except Exception:
        return None

def calc_minutes(a: datetime.time, b: datetime.time) -> int:
    dt_a = datetime.datetime.combine(datetime.date.today(), a)
    dt_b = datetime.datetime.combine(datetime.date.today(), b)
    return int((dt_b - dt_a).total_seconds() // 60)

def deviation_columns(start_dt: datetime.datetime | None, end_dt: datetime.datetime | None) -> tuple[int,int,int,int]:
    """(—Ä–∞–Ω—å—à–µ_–Ω–∞—á–∞–ª–æ, –ø–æ–∑–∂–µ_–Ω–∞—á–∞–ª–æ, —Ä–∞–Ω—å—à–µ_–∫–æ–Ω–µ—Ü, –ø–æ–∑–∂–µ_–∫–æ–Ω–µ—Ü) –≤ –º–∏–Ω—É—Ç–∞—Ö (>=0) ‚Äî –î–õ–Ø –û–¢–ß–Å–¢–ê"""
    early_start = late_start = early_end = late_end = 0
    if start_dt:
        st_local = start_dt.astimezone(MSK).time()
        if st_local < START_NORM:
            early_start = calc_minutes(st_local, START_NORM)
        if st_local > START_OK_TILL:
            late_start = calc_minutes(START_OK_TILL, st_local)
    if end_dt:
        en_local = end_dt.astimezone(MSK).time()
        if en_local < END_NORM:
            early_end = calc_minutes(en_local, END_NORM)
        if en_local > END_OK_TILL:
            late_end = calc_minutes(END_OK_TILL, en_local)
    return early_start, late_start, early_end, late_end

def minutes_between(start_dt: datetime.datetime | None, end_dt: datetime.datetime | None) -> int:
    if not start_dt or not end_dt:
        return 0
    a = start_dt.astimezone(MSK)
    b = end_dt.astimezone(MSK)
    if b < a:
        return 0
    return int((b - a).total_seconds() // 60)

def build_xlsx_bytes(date_from: datetime.date, date_to: datetime.date) -> bytes:
    wb = Workbook()
    ws_shifts = wb.active
    ws_shifts.title = "–°–º–µ–Ω—ã"
    ws_daily = wb.create_sheet("–°–≤–æ–¥ –ø–æ –¥–Ω—è–º")
    ws_emps = wb.create_sheet("–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏")
    ws_params = wb.create_sheet("–ü–∞—Ä–∞–º–µ—Ç—Ä—ã")

    # ---- –®–∞–ø–∫–∏
    shifts_header = [
        "–î–∞—Ç–∞","–°–æ—Ç—Ä—É–¥–Ω–∏–∫","ID","–ù–∞—á–∞–ª–æ","–ö–æ–Ω–µ—Ü",
        "–†–∞–Ω–Ω–µ–µ –Ω–∞—á–∞–ª–æ, –º–∏–Ω","–ü–æ–∑–¥–Ω–µ–µ –Ω–∞—á–∞–ª–æ, –º–∏–Ω","–†–∞–Ω–Ω–µ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ, –º–∏–Ω","–ü–æ–∑–¥–Ω–µ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ, –º–∏–Ω",
        "–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, –º–∏–Ω","–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, —á","–í—ã—Ö–æ–¥–Ω–æ–π","–ü—Ä–∏—á–∏–Ω–∞ –Ω–∞—á–∞–ª–∞","–ü—Ä–∏—á–∏–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è","–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π"
    ]
    ws_shifts.append(shifts_header)

    daily_header = [
        "–î–∞—Ç–∞","–°–æ—Ç—Ä—É–¥–Ω–∏–∫","ID","–ù–∞—á–∞–ª–æ","–ö–æ–Ω–µ—Ü",
        "–†–∞–Ω–Ω–µ–µ –Ω–∞—á–∞–ª–æ, –º–∏–Ω","–ü–æ–∑–¥–Ω–µ–µ –Ω–∞—á–∞–ª–æ, –º–∏–Ω","–†–∞–Ω–Ω–µ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ, –º–∏–Ω","–ü–æ–∑–¥–Ω–µ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ, –º–∏–Ω",
        "–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, –º–∏–Ω","–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, —á","–í—ã—Ö–æ–¥–Ω–æ–π"
    ]
    ws_daily.append(daily_header)

    ws_emps.append(["ID","–°–æ—Ç—Ä—É–¥–Ω–∏–∫"])
    for uid, name in sorted(EMPLOYEES.items()):
        ws_emps.append([uid, name])

    ws_params.append(["–ü–∞—Ä–∞–º–µ—Ç—Ä","–ó–Ω–∞—á–µ–Ω–∏–µ"])
    ws_params.append(["–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å","Europe/Moscow"])
    ws_params.append(["–ù–æ—Ä–º–∞ –Ω–∞—á–∞–ª–∞","08:00"])
    ws_params.append(["–î–æ–ø—É—Å—Ç–∏–º–æ –¥–æ (–Ω–∞—á–∞–ª–æ)","08:10"])
    ws_params.append(["–ù–æ—Ä–º–∞ –∫–æ–Ω—Ü–∞","17:30"])
    ws_params.append(["–î–æ–ø—É—Å—Ç–∏–º–æ –¥–æ (–∫–æ–Ω–µ—Ü)","17:40"])
    ws_params.append(["–ü–µ—Ä–∏–æ–¥ –æ—Ç—á—ë—Ç–∞", f"{date_from.isoformat()} ‚Äî {date_to.isoformat()}"])

    # ---- –î–∞–Ω–Ω—ã–µ
    for day in daterange_inclusive(date_from, date_to):
        key = day.isoformat()
        day_data = shifts_by_date.get(key, {})
        weekend = "–î–∞" if is_weekend(day) else "–ù–µ—Ç"

        for uid, data in day_data.items():
            name = fio(uid)
            start_dt: datetime.datetime | None = data.get("start")
            end_dt:   datetime.datetime | None = data.get("end")

            start_str = fmt_hm(start_dt)
            end_str   = fmt_hm(end_dt)

            early_start, late_start, early_end, late_end = deviation_columns(start_dt, end_dt)
            work_min = minutes_between(start_dt, end_dt)
            work_hours = round(work_min/60, 2)

            ws_shifts.append([
                day, name, uid, start_str, end_str,
                early_start, late_start, early_end, late_end,
                work_min, work_hours, weekend,
                data.get("start_reason") or "",
                data.get("end_reason") or "",
                data.get("comment") or "",
            ])

            ws_daily.append([
                day, name, uid, start_str, end_str,
                early_start, late_start, early_end, late_end,
                work_min, work_hours, weekend
            ])

    # ---- –§–æ—Ä–º–∞—Ç—ã —Å—Ç–æ–ª–±—Ü–æ–≤ –∏ –Ω–µ–º–Ω–æ–≥–æ –∫—Ä–∞—Å–æ—Ç—ã
    def fit_columns(ws):
        widths = {}
        for row in ws.iter_rows(values_only=True):
            for i, cell in enumerate(row, 1):
                s = "" if cell is None else str(cell)
                widths[i] = max(widths.get(i, 0), len(s))
        for i, w in widths.items():
            ws.column_dimensions[get_column_letter(i)].width = min(max(10, w + 2), 40)

    for ws in (ws_shifts, ws_daily, ws_emps, ws_params):
        fit_columns(ws)
        # —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏
        for cell in next(ws.iter_rows(min_row=1, max_row=1)):
            cell.font = Font(bold=True)
            cell.alignment = Alignment(horizontal="center")

    bio = io.BytesIO()
    wb.save(bio)
    return bio.getvalue()

# ======== FSM: –ø—Ä–æ—Å–∏–º –ø–µ—Ä–∏–æ–¥ —É –∞–¥–º–∏–Ω–∞ –ø–æ –∫–Ω–æ–ø–∫–µ ¬´–û—Ç—á–µ—Ç üìà¬ª ========
class ReportStates(StatesGroup):
    waiting_period = State()

@router.message(F.text == "–û—Ç—á–µ—Ç üìà")
async def ask_report_period(message: Message, state: FSMContext):
    if not ensure_allowed(message): return
    if not is_admin(message.from_user.id):
        await message.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", reply_markup=kb(message.from_user.id))
        return
    await state.set_state(ReportStates.waiting_period)
    await message.answer(
        "–í–≤–µ–¥–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –¥–∞—Ç (–≤–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ) –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
        "‚Ä¢ –û–¥–∏–Ω –¥–µ–Ω—å: <code>2025-08-20</code>\n"
        "‚Ä¢ –î–∏–∞–ø–∞–∑–æ–Ω: <code>2025-08-01 2025-08-20</code>\n"
        "–î–ª—è –æ—Ç–º–µ–Ω—ã: /cancel"
    )

@router.message(Command("cancel"))
async def cancel_report(message: Message, state: FSMContext):
    await state.clear()
    await message.answer("–û—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=kb(message.from_user.id))

@router.message(ReportStates.waiting_period, F.text)
async def handle_report_period(message: Message, state: FSMContext):
    if not is_admin(message.from_user.id):
        await message.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", reply_markup=kb(message.from_user.id))
        await state.clear()
        return

    parts = message.text.strip().split()
    if len(parts) == 1:
        d1 = parse_date(parts[0]); d2 = d1
    elif len(parts) == 2:
        d1 = parse_date(parts[0]); d2 = parse_date(parts[1])
    else:
        d1 = d2 = None

    if not d1 or not d2:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü—Ä–∏–º–µ—Ä: <code>2025-08-01 2025-08-20</code> –∏–ª–∏ <code>2025-08-20</code>")
        return

    if d2 < d1:
        d1, d2 = d2, d1

    if (d2 - d1).days > 92:
        await message.answer("–°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥ (>92 –¥–Ω–µ–π). –°–æ–∫—Ä–∞—Ç–∏—Ç–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª.")
        await state.clear()
        return

    has_any = any(shifts_by_date.get(day.isoformat()) for day in daterange_inclusive(d1, d2))
    if not has_any:
        await message.answer("–í —É–∫–∞–∑–∞–Ω–Ω–æ–º –ø–µ—Ä–∏–æ–¥–µ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö.")
        await state.clear()
        return

    try:
        xlsx = build_xlsx_bytes(d1, d2)
        fname = f"–û—Ç—á—ë—Ç_{d1.isoformat()}_{d2.isoformat()}.xlsx" if d1 != d2 else f"–û—Ç—á—ë—Ç_{d1.isoformat()}.xlsx"
        await message.answer_document(
            BufferedInputFile(xlsx, filename=fname),
            caption=f"–û—Ç—á—ë—Ç –∑–∞ –ø–µ—Ä–∏–æ–¥ {d1.isoformat()} ‚Äî {d2.isoformat()} (–ú–°–ö).",
            reply_markup=kb(message.from_user.id)
        )
    except Exception as e:
        logging.exception("–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç—á—ë—Ç–∞: %s", e)
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á—ë—Ç. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–∞–Ω–Ω—ã–µ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")
    finally:
        await state.clear()

# ================== –°–í–û–ë–û–î–ù–´–ô –¢–ï–ö–°–¢ (–ø—Ä–∏—á–∏–Ω—ã/–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏) ==================
@router.message()
async def handle_comment_or_reason(message: Message):
    if not ensure_allowed(message): return
    uid = message.from_user.id
    txt = (message.text or "").strip()
    if not txt:
        return

    # –ï—Å–ª–∏ –∂–¥—ë–º –ø—Ä–∏—á–∏–Ω—É ‚Äî —Å–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–æ –≤ start_reason/end_reason
    reason_flag = pending_reason.get(uid)
    if reason_flag:
        shift = shifts_by_date.get(today_key(), {}).get(uid)
        if not shift:
            pending_reason.pop(uid, None)
            return
        if reason_flag in ("start_early", "start_late"):
            shift["start_reason"] = txt
            await message.answer("–°–ø–∞—Å–∏–±–æ! –ü—Ä–∏—á–∏–Ω–∞ –Ω–∞—á–∞–ª–∞ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞.", reply_markup=kb(uid))
        elif reason_flag in ("end_early", "end_late"):
            shift["end_reason"] = txt
            await message.answer("–°–ø–∞—Å–∏–±–æ! –ü—Ä–∏—á–∏–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞.", reply_markup=kb(uid))
        pending_reason.pop(uid, None)
        save_shifts()
        return

    # –ò–Ω–∞—á–µ ‚Äî —ç—Ç–æ –æ–±—â–∏–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ —Ç–µ–∫—É—â–µ–π —Å–º–µ–Ω–µ
    shift = shifts_by_date.get(today_key(), {}).get(uid)
    if not shift:
        return
    if shift.get("start") and not shift.get("end") and not shift.get("comment"):
        shift["comment"] = txt
        await message.answer("–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π —Å–æ—Ö—Ä–∞–Ω—ë–Ω. –ü—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ–≥–æ –¥–Ω—è!", reply_markup=kb(uid))
        save_shifts()
    elif shift.get("end") and not shift.get("comment_done"):
        shift["comment_done"] = True
        await message.answer("–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –ø–æ–ª—É—á–µ–Ω. –•–æ—Ä–æ—à–µ–≥–æ –æ—Ç–¥—ã—Ö–∞!", reply_markup=kb(uid))
        save_shifts()

# ================== –ó–ê–ü–£–°–ö ==================
async def main():
    try:
        me = await bot.get_me()
        logging.info("–ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –∫–∞–∫ @%s (id=%s)", me.username, me.id)

        # –ë–∞–∑–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã (–≤–∏–¥–Ω—ã –≤—Å–µ–º)
        base_cmds = [
            BotCommand(command="start", description="–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"),
            BotCommand(command="whoami", description="–ü–æ–∫–∞–∑–∞—Ç—å –º–æ—é —Ä–æ–ª—å"),
            BotCommand(command="cancel", description="–û—Ç–º–µ–Ω–∏—Ç—å –≤–≤–æ–¥ –ø–µ—Ä–∏–æ–¥–∞"),
        ]
        await bot.set_my_commands(base_cmds, scope=BotCommandScopeDefault())

        # –î–æ–ø. –∫–æ–º–∞–Ω–¥—ã —Ç–æ–ª—å–∫–æ OWNER (–≤–∏–¥–Ω—ã —Ç–æ–ª—å–∫–æ —Ç–µ–±–µ –≤ –ª–∏—á–∫–µ)
        owner_cmds = base_cmds + [
            BotCommand(command="emp_list", description="(OWNER) –°–ø–∏—Å–æ–∫ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤"),
            BotCommand(command="emp_add", description="(OWNER) –î–æ–±–∞–≤–∏—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞"),
            BotCommand(command="emp_del", description="(OWNER) –£–¥–∞–ª–∏—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞"),
            BotCommand(command="emp_reload", description="(OWNER) –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫"),
        ]
        await bot.set_my_commands(owner_cmds, scope=BotCommandScopeChat(chat_id=OWNER_ID))

        await dp.start_polling(bot)
    except Exception as e:
        logging.exception("–°—Ç–∞—Ä—Ç –Ω–µ —É–¥–∞–ª—Å—è: %s", e)
    finally:
        # –°–æ—Ö—Ä–∞–Ω–∏–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–º–µ–Ω –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
        try:
            save_shifts()
        finally:
            await bot.session.close()

if __name__ == "__main__":
    asyncio.run(main())
